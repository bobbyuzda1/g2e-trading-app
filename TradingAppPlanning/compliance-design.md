# G2E Compliance Design

## Overview

This document defines the regulatory compliance framework for the G2E Trading Application. The application provides AI-powered trading analysis and recommendations, requiring adherence to SEC, FINRA, and financial privacy regulations.

---

## Regulatory Requirements

### SEC Rules 17a-3 and 17a-4 (Recordkeeping)

**Requirement:** Broker-dealers must maintain accurate books and records, including records of all communications related to securities business.

**Application to G2E:**

| Record Type | Retention Period | Format |
|-------------|------------------|--------|
| Trade recommendations | 6 years (first 2 years accessible) | Immutable database + backup |
| AI analysis results | 6 years | JSON with timestamp |
| User communications (chat) | 6 years | Conversation logs |
| Audit trail events | 6 years | Append-only log |
| Account linking records | 6 years | OAuth metadata |

**Implementation:**
- All records stored in PostgreSQL with `deleted_at IS NULL` soft-delete pattern
- Nightly backups to encrypted cloud storage
- Quarterly archive migration to cold storage after 2 years

---

### FINRA Regulation Best Interest (Reg BI)

**Requirement:** Recommendations must be in the customer's best interest and disclose conflicts of interest.

**Application to G2E:**

Every AI-generated recommendation must include:

1. **Disclosure Obligation** - Clear statement that this is AI-generated analysis
2. **Care Obligation** - Demonstration that recommendation aligns with user's stated strategy
3. **Conflict Disclosure** - Any potential conflicts (none expected for self-directed platform)
4. **Basis Disclosure** - Explanation of the data and logic behind the recommendation

**Required Disclosure Text (Every Recommendation):**

```
---
IMPORTANT DISCLOSURES:
- This analysis was generated by artificial intelligence (Google Gemini)
- This is informational analysis, not personalized investment advice
- Past performance does not guarantee future results
- Consult a licensed financial advisor for personalized guidance
- Data current as of: [TIMESTAMP]
- Based on your stated strategy: [STRATEGY_SUMMARY]
---
```

---

### FINRA Rule 4510 (Books and Records)

**Requirement:** 6-year retention for communications and 3-year retention for general records.

**Application to G2E:**

| Category | Retention | Examples |
|----------|-----------|----------|
| Trade communications | 6 years | Chat messages, email confirmations |
| Trade records | 6 years | Recommendations, approvals, executions |
| Account records | 6 years | E*TRADE linking, strategy changes |
| System logs | 3 years | API calls, errors, performance metrics |
| Session data | 3 years | Login events, token refreshes |

**Implementation:**
- `created_at` timestamp on all records
- `archived_at` for cold storage migration
- No physical deletion for compliance-relevant records
- Legal hold capability for investigation support

---

### GLBA (Gramm-Leach-Bliley Act) - Financial Privacy

**Requirement:** Protect consumer financial information (NPI - Nonpublic Personal Information).

**NPI in G2E Context:**
- E*TRADE account information
- Portfolio holdings and values
- Transaction history
- Trading strategy details
- Communication content

**Safeguards Program:**

| Control | Implementation |
|---------|----------------|
| Encryption at rest | AES-256 for database, storage |
| Encryption in transit | TLS 1.3 minimum for all connections |
| Access controls | Role-based access, principle of least privilege |
| Employee training | N/A (single-user application) |
| Vendor management | Secure contracts with Gemini, E*TRADE |
| Incident response | Documented breach notification procedures |

---

## AI-Specific Compliance

### AI Content Disclosure

**Requirement:** Users must know when content is AI-generated.

**Implementation:**

Every AI response includes:

```python
AI_DISCLOSURE_HEADER = """
[AI-GENERATED ANALYSIS]
Model: Google Gemini {model_version}
Generated: {timestamp}
Context: {strategy_summary}
"""

AI_DISCLOSURE_FOOTER = """
---
This analysis is AI-generated and for informational purposes only.
Not a recommendation to buy, sell, or hold any security.
"""
```

### AI Response Quality Controls

| Control | Threshold | Action |
|---------|-----------|--------|
| Confidence threshold | < 0.65 | Warn user, suggest manual review |
| Response length | > 4000 tokens | Summarize, offer detailed view |
| Strategy conflict | Any detected | Explicit warning in response |
| Data staleness | > 24 hours | Warning about data age |

---

## Audit Logging Architecture

### Audit Events

All security-relevant and compliance-relevant events are logged immutably.

**Event Categories:**

| Category | Events |
|----------|--------|
| Authentication | Login, logout, token refresh, OAuth linking, MFA events |
| Authorization | Permission checks, access denials |
| Data Access | Portfolio views, transaction history pulls |
| AI Interactions | Recommendations generated, strategy analyses |
| Trading Actions | Order previews, order submissions, confirmations |
| Configuration | Strategy updates, plan changes, settings modifications |
| System | API failures, rate limit hits, security alerts |

### Audit Log Schema

```sql
-- Immutable audit log table (append-only)
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Event identification
    event_id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL,
    event_category VARCHAR(50) NOT NULL,

    -- Actor information
    user_id UUID REFERENCES users(id),
    session_id UUID,
    ip_address INET,
    user_agent TEXT,

    -- Event details
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100),
    resource_id VARCHAR(255),

    -- Context
    request_id UUID,
    correlation_id UUID,  -- Links related events

    -- Data (before/after for changes)
    old_value JSONB,
    new_value JSONB,
    metadata JSONB,

    -- Compliance
    data_classification VARCHAR(20) DEFAULT 'internal',  -- public, internal, confidential, restricted
    retention_until DATE NOT NULL,

    -- Integrity
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    checksum VARCHAR(64) NOT NULL,  -- SHA-256 of event data
    previous_checksum VARCHAR(64),  -- Chain integrity

    -- Prevent modifications
    CONSTRAINT no_updates CHECK (TRUE)  -- Enforced via triggers
);

-- Prevent UPDATE and DELETE operations
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Audit logs cannot be modified or deleted';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_immutability
    BEFORE UPDATE OR DELETE ON audit_logs
    FOR EACH ROW
    EXECUTE FUNCTION prevent_audit_modification();

-- Indexes for compliance queries
CREATE INDEX idx_audit_user ON audit_logs(user_id, created_at);
CREATE INDEX idx_audit_type ON audit_logs(event_type, created_at);
CREATE INDEX idx_audit_category ON audit_logs(event_category, created_at);
CREATE INDEX idx_audit_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_retention ON audit_logs(retention_until);

-- Partition by month for performance and archival
-- Implementation: Use pg_partman for automatic partition management
```

### Audit Log Implementation

```python
# app/services/audit_service.py
import hashlib
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from uuid import uuid4

class AuditService:
    """
    Immutable audit logging for compliance requirements.
    All events are append-only with cryptographic integrity verification.
    """

    RETENTION_PERIODS = {
        'authentication': timedelta(days=2190),  # 6 years
        'authorization': timedelta(days=2190),
        'data_access': timedelta(days=2190),
        'ai_interaction': timedelta(days=2190),
        'trading_action': timedelta(days=2190),
        'configuration': timedelta(days=2190),
        'system': timedelta(days=1095),  # 3 years
    }

    DATA_CLASSIFICATIONS = {
        'public': 'Non-sensitive information',
        'internal': 'Internal business data',
        'confidential': 'User PII, financial data',
        'restricted': 'Credentials, tokens, keys'
    }

    async def log_event(
        self,
        event_type: str,
        event_category: str,
        action: str,
        user_id: Optional[str] = None,
        session_id: Optional[str] = None,
        resource_type: Optional[str] = None,
        resource_id: Optional[str] = None,
        old_value: Optional[Dict] = None,
        new_value: Optional[Dict] = None,
        metadata: Optional[Dict] = None,
        request_context: Optional[Dict] = None,
        data_classification: str = 'internal'
    ) -> str:
        """
        Log an audit event with cryptographic integrity.

        Returns:
            Event ID for reference
        """
        event_id = str(uuid4())
        created_at = datetime.utcnow()

        # Calculate retention date based on category
        retention_period = self.RETENTION_PERIODS.get(
            event_category,
            timedelta(days=2190)  # Default 6 years
        )
        retention_until = (created_at + retention_period).date()

        # Get previous checksum for chain integrity
        previous = await self._get_latest_checksum()

        # Build event data for checksum
        event_data = {
            'event_id': event_id,
            'event_type': event_type,
            'event_category': event_category,
            'action': action,
            'user_id': user_id,
            'resource_type': resource_type,
            'resource_id': resource_id,
            'created_at': created_at.isoformat(),
            'previous_checksum': previous
        }

        # Calculate checksum
        checksum = hashlib.sha256(
            json.dumps(event_data, sort_keys=True).encode()
        ).hexdigest()

        # Sanitize sensitive data before logging
        sanitized_old = self._sanitize_for_logging(old_value, data_classification)
        sanitized_new = self._sanitize_for_logging(new_value, data_classification)

        # Insert into audit log
        await self.db.execute("""
            INSERT INTO audit_logs (
                event_id, event_type, event_category, action,
                user_id, session_id, ip_address, user_agent,
                resource_type, resource_id, request_id, correlation_id,
                old_value, new_value, metadata,
                data_classification, retention_until,
                created_at, checksum, previous_checksum
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
                $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
            )
        """,
            event_id, event_type, event_category, action,
            user_id, session_id,
            request_context.get('ip') if request_context else None,
            request_context.get('user_agent') if request_context else None,
            resource_type, resource_id,
            request_context.get('request_id') if request_context else None,
            request_context.get('correlation_id') if request_context else None,
            json.dumps(sanitized_old) if sanitized_old else None,
            json.dumps(sanitized_new) if sanitized_new else None,
            json.dumps(metadata) if metadata else None,
            data_classification, retention_until,
            created_at, checksum, previous
        )

        return event_id

    def _sanitize_for_logging(
        self,
        data: Optional[Dict],
        classification: str
    ) -> Optional[Dict]:
        """Remove or mask sensitive fields before logging."""
        if not data:
            return None

        sanitized = data.copy()

        # Always redact these fields
        sensitive_fields = [
            'password', 'token', 'secret', 'key', 'credential',
            'access_token', 'refresh_token', 'api_key', 'ssn',
            'account_number', 'routing_number'
        ]

        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = '[REDACTED]'
            # Check nested dicts
            for key, value in sanitized.items():
                if isinstance(value, dict) and field in value:
                    sanitized[key][field] = '[REDACTED]'

        return sanitized

    async def _get_latest_checksum(self) -> Optional[str]:
        """Get the most recent checksum for chain integrity."""
        result = await self.db.fetchone(
            "SELECT checksum FROM audit_logs ORDER BY created_at DESC LIMIT 1"
        )
        return result['checksum'] if result else None


# Convenience logging functions
async def log_authentication_event(
    audit: AuditService,
    action: str,  # 'login', 'logout', 'token_refresh', 'oauth_link'
    user_id: str,
    success: bool,
    metadata: Dict = None,
    request_context: Dict = None
):
    await audit.log_event(
        event_type=f'auth.{action}',
        event_category='authentication',
        action=f'{action}_{"success" if success else "failure"}',
        user_id=user_id,
        metadata={'success': success, **(metadata or {})},
        request_context=request_context,
        data_classification='confidential'
    )


async def log_ai_recommendation(
    audit: AuditService,
    user_id: str,
    recommendation: Dict,
    strategy_context: Dict,
    request_context: Dict = None
):
    """Log AI recommendation for Reg BI compliance."""
    await audit.log_event(
        event_type='ai.recommendation',
        event_category='ai_interaction',
        action='recommendation_generated',
        user_id=user_id,
        resource_type='trade_recommendation',
        resource_id=recommendation.get('id'),
        new_value={
            'ticker': recommendation.get('ticker'),
            'action': recommendation.get('action'),
            'confidence': recommendation.get('confidence'),
            'strategy_alignment': recommendation.get('strategy_alignment'),
            'reasoning_summary': recommendation.get('reasoning', {}).get('strategy_fit')
        },
        metadata={
            'model': recommendation.get('model_used'),
            'strategy_id': strategy_context.get('id'),
            'active_plan_id': strategy_context.get('active_plan_id')
        },
        request_context=request_context,
        data_classification='confidential'
    )


async def log_trade_action(
    audit: AuditService,
    user_id: str,
    action: str,  # 'preview', 'submit', 'confirm', 'cancel'
    order_details: Dict,
    request_context: Dict = None
):
    """Log trade-related actions."""
    await audit.log_event(
        event_type=f'trade.{action}',
        event_category='trading_action',
        action=action,
        user_id=user_id,
        resource_type='order',
        resource_id=order_details.get('order_id'),
        new_value={
            'ticker': order_details.get('ticker'),
            'action': order_details.get('action'),
            'quantity': order_details.get('quantity'),
            'order_type': order_details.get('order_type'),
            'limit_price': order_details.get('limit_price')
        },
        metadata={
            'etrade_order_id': order_details.get('etrade_order_id'),
            'recommendation_id': order_details.get('recommendation_id')
        },
        request_context=request_context,
        data_classification='confidential'
    )
```

---

## Required Legal Documents

### Documents to Create Before Launch

| Document | Purpose | Review Frequency |
|----------|---------|------------------|
| Terms of Service | User agreement, liability limitations | Annual |
| Privacy Policy | GLBA compliance, data handling | Annual |
| Risk Disclosure | SEC/FINRA requirement | Annual |
| AI Disclosure Statement | Transparency on AI usage | Annual |
| Fee Schedule | Cost transparency (if applicable) | As needed |
| Electronic Consent | E-Sign Act compliance | Initial setup |

### Terms of Service Key Provisions

1. **Service Description** - AI-powered analysis tool, not investment advisor
2. **No Investment Advice** - Information only, not personalized recommendations
3. **User Responsibility** - User makes all trading decisions
4. **Accuracy Disclaimer** - AI may make errors, data may be delayed
5. **Limitation of Liability** - No liability for trading losses
6. **Dispute Resolution** - Arbitration clause

### Privacy Policy Key Provisions

1. **Information Collected** - Account data, portfolio data, usage data
2. **How We Use Information** - AI analysis, service improvement
3. **Third-Party Sharing** - E*TRADE (for trading), Google (for AI)
4. **Data Retention** - 6 years per FINRA requirements
5. **User Rights** - Access, correction (deletion limited by retention rules)
6. **Security Measures** - Encryption, access controls

---

## Compliance Checklist

### Pre-Launch Compliance Tasks

- [ ] Implement audit logging with immutability
- [ ] Add disclosure text to all AI responses
- [ ] Create Terms of Service document
- [ ] Create Privacy Policy document
- [ ] Create Risk Disclosure document
- [ ] Configure data encryption (at rest and in transit)
- [ ] Implement data retention policies
- [ ] Set up backup procedures
- [ ] Document incident response plan
- [ ] Review all AI prompts for compliance

### Ongoing Compliance Tasks

| Task | Frequency |
|------|-----------|
| Audit log integrity verification | Daily |
| Backup verification | Weekly |
| Access review | Monthly |
| Legal document review | Annually |
| Retention policy enforcement | Quarterly |
| Security assessment | Annually |

---

## Disclaimer Templates

### Standard AI Response Disclaimer

```
---
IMPORTANT: This analysis was generated by AI (Google Gemini) as of [TIMESTAMP].
This is informational content only, not personalized investment advice.
Past performance does not guarantee future results.
Consult a licensed financial advisor before making investment decisions.
Based on your strategy: [STRATEGY_SUMMARY]
---
```

### Trade Recommendation Disclaimer

```
---
AI-GENERATED TRADE ANALYSIS

This recommendation is generated by artificial intelligence based on:
- Your stated trading strategy
- Current market data (as of [TIMESTAMP])
- Technical and fundamental indicators

IMPORTANT DISCLOSURES:
1. This is not personalized investment advice
2. The AI may make errors in analysis
3. Market conditions can change rapidly
4. You are responsible for your own trading decisions
5. Consider consulting a licensed financial advisor

Strategy alignment: [STRATEGY_RULE_CITED]
Confidence level: [CONFIDENCE_SCORE]%
---
```

### Chat Conversation Disclaimer

```
[Shown at start of each conversation]

You're chatting with an AI assistant (Google Gemini) that has context about:
- Your trading strategy
- Your active plan (if any)
- Your portfolio (if linked)

This is a general-purpose assistant for research and analysis.
Any trade suggestions are not personalized investment advice.
All information should be verified before acting.
```

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-01-24 | Initial compliance framework |
